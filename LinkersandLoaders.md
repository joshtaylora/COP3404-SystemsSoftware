# Linkers and Loaders
***
## Background
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The user view of a computer program often views a program as being one monolithic file that the user double clicks the icon for it on their desktop, clicks a start menu entry, types the program name in the terminal, or some other system-dependant program execution method, and that after that the program just _works_. From a C programming point of view, a level of abstraction from the user's view gets removed and we can see that a typical program is a collection of source files written in some high-level langauge like C that allow a programmer to separate different program functionality into separate source files to allow for increased cohesion, increased modularity, and decreased coupling. This view allows for each source file to be compiled separately into individual object files that will then be linked into a single executable. It is the role of the `linker` to perform the task of linking multiple object files together into one executable. Once the files have been linked together, when the executable is run, it is passed to a loader which loads the program into memory, one instruction at a time. 
## Linker
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;There are two main types of linkers today: static linkers and dynamic linkers. `Static linkers` take input in the form of relocatable object files and generate a single executable object file that can be loaded and run separately. They must perform two primary tasks: symbol resolution and relocation. `Symbol resolution` involves finding each symbol referenced in the object files given as input and associate them with 1 symbol definition. Once symbol resolution has been performed, the linker then performs `relocation` by taking the memory locations associated with each symbol definition and modifying the references to those symbols to point to that memory location. The relocation is performed according to output from the assembler that details how to relocate the symbol in the object file. In SIC and SIC/XE these assembler-to-linker instructions are called Modified Records and they are stored in the object file output from the assembler, much like the relocation entries in the object file output of the Linux LD linker. 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Static linkers allow for the use of static libraries by user programs. `Static libaries` are special files that are generated by an archiving tool that contain several relocatable object files in one single `archive`, allowing for a program to reference symbols from several object files. Linking your program with a static library means that whenever a change occurs within one of the C source files that is compiled and assembled into one of the object files in the archive, you must recompile the entire program and archive in order to see the effects of this change. At run time, the code for funcions located in static libraries is duplicated into the text section for all of the concurrent processes using that static library. This is an extremely inefficient use of memory space that is an unavoidable byproduct of using a static linker since symbol resolution is performed at link-time and memory addresses are defined at run-time.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`Dynamic linkers`, on the other hand, make use of a special kind of object file called a shared object file. A `shared object file` is a type of relocatable object file that can be linked _dynamically_, at either load time or run time. Using C shared libraries using the linux dynamic linker, when linked at load-time, works as such:
```
1. Compile main2.c and vector.h using gcc to get: main2.o, a relocatable object file

2. Create a shared library called libvector.so that contains the addvec.c and multvec.c source files through the unix command:
    $ gcc - shared -o libvector.so addvec.c multvec.c

3. Link main2.o with our new shared library, libvector.so and the c standard library, libc.so using the linux linker, ld to get our partially linked executable object file, prog21

4. Call the loader on prog21 using the execve command will invoke the dynamic linker, ld-linux.so, which will dynamically link the libc.so and libvector.so shared libraries into the prog21 process space 
```
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When a shared object file gets loaded into memory, only one copy of it needs to be loaded into the logical address space while still allowing all concurrent processes that have been linked to it to access it. When the loader loads and runs an executable that contains an ELF .interp section, it loads and runs the dynamic linker instead of passing control off to the application. Once the dynamic linker is executing, it starts by relocating the text and data sections of any shared libraries referenced in the .interp section of the ELF object file for the program into a memory segment. Next, any references to symbols defined in the (now relocated) shared libraries are also relocated. Once the dynamic linker passes control to the program application, the locations of the shared libraries are fixed in memory.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The object file format for shared libraries, ELF, is defined so that there are clear sections in the object file that divide the code, data, symbol table, and other segments in a well documented and standardized way. When the gcc compiler compiles the code segments for shared modules, it does so so that they can be loaded into memory completely independent of any modification from the linker. Code that is compiled in this manner is known as `Position-Independent Code` (PIC). On modern x86-64 computer systems, PC-relative addressing is used when the compiler compiles symbols with in the same executable object file, ensuring that they are PIC. The data segment for object modules is always the same offset from the code segment which can be exploited by the compiler to generat global variable references that are PIC. This is done by making a table called the `global offset table` that is located at the beginning of the data segment. It contains entries for each `global data object`, a procedure/function or a global variable, that is referenced in the object module and at load time, these references are relocated so that each entry in the table contains the absolute address of the object it is referencing. 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Now that a cursory introduction to C program compilation, linking, and loading has been discussed, we have all of the pieces necessary to understand how the SIC/XE Linker and Loader work.
***
## SIC/XE System View
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In the SIC/XE assembly language, when the assembler detects that a symbol has been defined using an `absolute address`, an exact memory location in which a symbol is defined at, it writes a Modification Record to the object file. This modification record is used by the linker and loader to perform the correct address modification depending on where in memory the object file gets loaded.
If all subroutines in a SIC/XE library needed to be loaded into memory at once in order for just a single one to be available to a program, we would be wasting enourmous amounts of memory just to be able to use a single subtroutine. This is what would happen if all addresses in SIC/XE were absolute addresses (like in SIC) and if the SIC/XE loader was an absolute loader. The design of the SIC/XE system is such that we have access to a larger memory region that allows for us to run multiple programs concurrently, sharing memory and system resources between them. This presents a view closer to modern operating system processes and threads of execution than that of the SIC system. In order to maximize memory utilization, we need to introduce the idea of program blocks and control sections. 
### Program Blocks
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`Program blocks` are segments of the SIC/XE source code that are rearranged within the object program module. These allow the programmer to define separate code and data sections, mimicing some of the structure of the ELF object file format to increases readability and usability. The `USE` assembler directive is indicates which part of the source program belongs to the different program blocks. Until a `USE` is located, all of the statements are included in the default block. You can indicate to the assembler that the statements after a named block defined by `USE` are a continuation of the default block by using the `USE` directive with no operand. 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The assembler will logically rearrange segments of the same program block to be gathered into the same block. Program blocks are then assigned addresses by the assembler in the object program in the order in which the blocks appear first in the source program. This is accomplished in Pass 1 of the assembler by initializing a separate program counter for each program block to 0 when the block first begins and then assigning addresses to each label that are relative to the start of the block it is contained within. The symbol table is modified from the original SIC design to contain the label of the symbol, the block name (or number) and the assigned relative address. After pass 1 has completed, the array of location counters for each block contains the length of each block (since we begin the block with relative address 0). Since the assembler now knows the length of each program block, the assembler can now assign a starting address to each program block. 
### Control Sections
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`Control sections` are segments in the SIC/XE source code that get translated into independent object program modules and maintains its identity after assembly. This means that each control section in a program can be loaded relocated outside of the other sections. We can use control sections to better simulate how subroutines work in real world assembly languages. We can use the `CSECT` directive to define control secions in a program. The `START` directive creates a control section whose name is the program label. 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The independent loading and relocation of control sections means that we need to tell the assembler when a control section needs to reference a symbol that is external to that control section so that it can be linked. We do this through the use of the `EXTREF` directive. We can only reference an external symbol through the `EXTREF` directive if that symbol has been defined as an external symbol through the use of the `EXTDEF` directive. This directive is used to pass external symbols to the loader so that they can be referenced in other control sections via the `EXTREF` directive. Control section names are automatically considered external symbols. The assembler must store information in the symbol table to indicate what control section an external reference is defined in and it must check that any external references to that symbol occur in control blocks that have included that symbol in the `EXTREF` statement for the control block. Definitions of external symbols in different control blocks should not flag an error in the assembly process.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When we first define a symbol in a control block that we have indicated in a `EXTDEF` directive to be an external symbol, we have to use the extended format instruction format in the symbol's definition because we have no way of knowing what relative address the symbol will have when it is referenced in another control block. Any instruction that uses an external reference as an operand must also use the extended format instruction. The assembler will indicate an address of 0 for all instructions used this way. This leads to the introduction of two new record types that are necessary to be able to link and load external references, as well as the new modification record.
### Define Records
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`Define records` are created by the assembler to tell the loader what external references are defined in this control section.

**Syntax**: 
<table>
<tr>
<th>Col 1</th>
<th>Col 2 - 7</th>
<th>Col 8 - 13</th>
<th>Col 14 - 73</th>
</tr>
<tr>
<td>D</td>
<td>Name of external sybol defined in this control section</td>
<td>Relateive address of symbol defined within this control section</td>
<td>Repeat the name and relative address info in Col 2-1 for other external symbols</td>
</tr>
</table>

### Refer Records
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`Refer records` are created by the assembler to tell the loader the names of all external symbols referenced in this control section

**Syntax**:

<table>
<tr>
<th>Col 1</th>
<th>Col 2 - 7</th>
<th>Col 8 - 73</th>
</tr>
<tr>
<td>R</td>
<td>Name of external symbol referenced in this control section</td>
<td>Name of other external symbols referenced in this control section</td>
</tr>
</table>

### Modification Records 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`modification records` are used to indicate to the loader/linker that a particular symbol needs to have it's location modified (relative to its absolute address defined in the source program) for purposes of program relocation. This type of record is very important in ensuring that a reference to a symbol that is defined with an absolute address, that is, one that has an explicitly defined location in memory, be where the programmer intended it should be. 

**Syntax**:

<table>
<tr>
<th>Col 1</th>
<th>Col 2 - 7</th>
<th>Col 8 - 9</th>
<th>Col 10</th>
<th>Col 11 - 16</th>
</tr>
<tr>
<td>R</td>
<td>Starting address of the field to be modified, relative to the beginning of the control section</td>
<td>Length of the field to be modified, in half-bytes</td>
<td>Modification Flag (+ or -)</td>
<td>External symbol whose value is to be added to or subtracted from the indicated field</td>
</tr>
</table>


The following section details how a modification record is written for an external symbol reference.
Instructions
```C
Loc		Label	statement						object code
0000	COPY	START	0						
				EXTDEF	BUFFER,BUFFEND,LENGTH	
				EXTREF	RDREC,WRREC			
0000	FIRST	STL		RETADR					172027
0003 	CLOOP	+JSUB	RDREC 					4B100000 . must be modified because we have no knowledge of the address of the external symbol in the assembler
```
The location counter for the start of this instruction is 0003, this means that the address of RDREC (originally zeroed out in pass 1) will be at location 0004 because the hex value for the opcode only takes up a single byte. Because the address field of a format 4 instruction is 20 bits, the length of the field to be modified in half bytes is equal to five half bytes. The name of the external symbol that we are referencing is RDREC so we are indicate that we are adding it to this field using the '+ '  flag.
So, the object file modification for this reference is
```
M0000405+RDREC
```

Any absolute addresses defined in the program must have modification records constructed for them so that the control block can be relocated to whatever memory location it is loaded into with all internal referenced symbols in the right place.

## SIC/XE Linking Loader
In order to be able to implement a linking loader, the assembler for SIC/XE must implemen
